<!DOCTYPE html>
<html lang='en'>
<head>
  <meta charset='UTF-8'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0'>
  <title>David Daverio</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400&display=swap');
    body { margin: 0; overflow: hidden; background: black; color: white; font-family: 'Source Code Pro', monospace; }
    canvas { display: block; }
    footer {
      position: fixed;
      bottom: 0;
      width: 100%;
      text-align: center;
      color: white;
      padding: 10px 0;
      background: rgba(0, 0, 0, 0.8);
      font-family: 'Source Code Pro', monospace;
    }
  </style>
</head>
<body>
  <canvas id='webgl-canvas'></canvas>
  <canvas id='text-canvas' style='display: none;'></canvas>
  <script>
    function init() {
      const canvas = document.getElementById('webgl-canvas');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      console.log(canvas.width)
      console.log(canvas.height)
      const gl = canvas.getContext('webgl');
      if (!gl) { alert('WebGL not supported'); return; }

      // Draw Text on Hidden Canvas
      const textCanvas = document.getElementById('text-canvas');
      const ctx = textCanvas.getContext('2d');

      textToScreenRatio = 2
      textCanvas.width = canvas.width / textToScreenRatio * 4;
      textCanvas.height = canvas.height * 4;
      const displayText = 'David Daverio Home Page';
      ctx.fillStyle = 'white';
      let fontSize = 1000
      ctx.font = fontSize + 'px Source Code Pro';
      let textWidth = ctx.measureText(displayText).width;
      //console.log(textWidth);
      //console.log(textCanvas.width - 100)
      while (textWidth > textCanvas.width - 100) {  // 20px padding
        fontSize -= 2;
        ctx.font = fontSize + 'px Source Code Pro';
        textWidth = ctx.measureText(displayText).width;
        //console.log(textWidth);
      }
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.clearRect(0, 0, textCanvas.width, textCanvas.height);
      ctx.fillText(displayText, textCanvas.width / 2, textCanvas.height / 2);

      // Get Text Pixel Data
      const imageData = ctx.getImageData(0, 0, textCanvas.width, textCanvas.height);
      const pixels = imageData.data;
      const positions = [];

      // Convert 2D Text Pixels to WebGL Coordinates
      for (let y = 0; y < textCanvas.height; y += 1) {
        for (let x = 0; x < textCanvas.width; x += 1) {
          const i = (y * textCanvas.width + x) *4;
          if (pixels[i] > 128) {  // White pixel threshold
            const posX = ((x / textCanvas.width)-0.5)*2/textToScreenRatio;
            const posY = ((y / textCanvas.height)-0.5)*-2;
            positions.push(posX, posY);
          }
        }
      }

      // Generate Random Start Positions AFTER positions are populated
      const randomStartPositions = [];
      for (let i = 0; i < positions.length; i += 2) {
        const randomX = Math.random() * 2 - 1;  // Random between -1 and 1
        const randomY = Math.random() * 2 - 1;  // Random between -1 and 1
        randomStartPositions.push(randomX, randomY);
      }
      console.log(positions.length)

      // Vertex Shader
      const vertexShaderSource = `
        attribute vec2 a_position;
        void main() {
          gl_PointSize = 1.0;
          gl_Position = vec4(a_position, 0.0, 1.0);
        }
      `;

      // Fragment Shader
      const fragmentShaderSource = `
        precision mediump float;
        void main() {
          gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);  // Solid White Color
        }
      `;

      function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          console.error('Shader Compile Error:', gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
      const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program Link Error:', gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return;
      }

      const positionBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
      const positionLocation = gl.getAttribLocation(program, 'a_position');

      const duration = 2;
      function animate(){
        console.log(duration)
        const elapsed = (performance.now() - startTime) / 1000;  // In seconds
        //const t = 1 - Math.exp(-10 * elapsed / duration); // Normalized time [0, 1]
        const t = 1 - Math.pow(1 - (elapsed / duration), 5);
        const currentPositions = [];
        console.log(t)
        for (let i = 0; i < positions.length; i += 2) {
          const startX = randomStartPositions[i];
          const startY = randomStartPositions[i + 1];
          const endX = positions[i];
          const endY = positions[i + 1];

          const posX = startX + t * (endX - startX);
          const posY = startY + t * (endY - startY);

          currentPositions.push(posX, posY);
        }
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.useProgram(program);
        gl.enableVertexAttribArray(positionLocation);
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(currentPositions), gl.STATIC_DRAW);
        gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.POINTS, 0, positions.length / 2);


        if (elapsed < duration) {
          requestAnimationFrame(animate);
        }    

     }


      

      const startTime = performance.now();
      animate(10)
    }

    window.onload = init;
  </script>
</body>
<footer>
    Page under perpetual construction, Â© 2025 David Daverio
  </footer>
</html>